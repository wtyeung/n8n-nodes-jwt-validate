var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "lodash/isEqual", "lodash/pick"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeDiffStatus = void 0;
    exports.compareNodes = compareNodes;
    exports.compareWorkflowsNodes = compareWorkflowsNodes;
    const isEqual_1 = __importDefault(require("lodash/isEqual"));
    const pick_1 = __importDefault(require("lodash/pick"));
    var NodeDiffStatus;
    (function (NodeDiffStatus) {
        NodeDiffStatus["Eq"] = "equal";
        NodeDiffStatus["Modified"] = "modified";
        NodeDiffStatus["Added"] = "added";
        NodeDiffStatus["Deleted"] = "deleted";
    })(NodeDiffStatus || (exports.NodeDiffStatus = NodeDiffStatus = {}));
    function compareNodes(base, target) {
        const propsToCompare = ['name', 'type', 'typeVersion', 'webhookId', 'credentials', 'parameters'];
        const baseNode = (0, pick_1.default)(base, propsToCompare);
        const targetNode = (0, pick_1.default)(target, propsToCompare);
        return (0, isEqual_1.default)(baseNode, targetNode);
    }
    function compareWorkflowsNodes(base, target, nodesEqual = compareNodes) {
        const baseNodes = base.reduce((acc, node) => {
            acc.set(node.id, node);
            return acc;
        }, new Map());
        const targetNodes = target.reduce((acc, node) => {
            acc.set(node.id, node);
            return acc;
        }, new Map());
        const diff = new Map();
        for (const [id, node] of baseNodes.entries()) {
            if (!targetNodes.has(id)) {
                diff.set(id, { status: NodeDiffStatus.Deleted, node });
            }
            else if (!nodesEqual(baseNodes.get(id), targetNodes.get(id))) {
                diff.set(id, { status: NodeDiffStatus.Modified, node });
            }
            else {
                diff.set(id, { status: NodeDiffStatus.Eq, node });
            }
        }
        for (const [id, node] of targetNodes.entries()) {
            if (!baseNodes.has(id)) {
                diff.set(id, { status: NodeDiffStatus.Added, node });
            }
        }
        return diff;
    }
});
//# sourceMappingURL=workflow-diff.js.map